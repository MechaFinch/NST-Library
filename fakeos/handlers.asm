
;
;	FakeOS Interrupt Handlers
;

%include "fakeos.asm" as os
%include "terminal.asm" as term

%define KEY_BUFFER			0xF000_0000
%define KEYCODE_SHIFT		0x10
%define KEYCODE_CAPSLOCK	0x14

segfault_state:	db 0
shift_state:	db 0
capslock_state:	db 0

%define CHAR_BUFFER_SIZE 16

char_buffer:			resb CHAR_BUFFER_SIZE
char_buf_read_index:	db 0
char_buf_write_index:	db 0
char_buf_available:		db 0

key_state_table:	repeat 256, db 0



; keydown
; ISR for key pressed
keydown:
	PUSH A
	
	; get char
	MOVZ A, [KEY_BUFFER]
	AND AL, 0x7F
	
	; update state table
	PUSH BL
	MOV BL, 1
	MOV [key_state_table + A], BL
	POP BL
	
	CMP AL, KEYCODE_SHIFT ; if it's shift, mark shift held
	JE .shift
	
	CMP AL, KEYCODE_CAPSLOCK ; if its capslock, toggle capslock
	JE .caps_press
	
	CMP byte [capslock_state], 0
	JNZ .caps
	
.not_caps:
	CMP byte [shift_state], 0	; if shift held, apply table
	CMOVZ AL, [.non_shift_table + A]
	CMOVNZ AL, [.shift_table + A]
	JMP .add_char

.caps:
	CMP byte [shift_state], 0	; if shift held, apply table
	CMOVZ AL, [.caps_non_shift_table + A]
	CMOVNZ AL, [.caps_shift_table + A]

.add_char:
	; add to buffer
	CMP byte [char_buf_available], 16	; drop character if no space
	JAE .ret
	INC byte [char_buf_available]
	
	PUSH I
	
	MOVZ I, [char_buf_write_index]	; place character at write index
	MOV [char_buffer + I], AL
	
	INC I							; increment write index & character count
	CMP I, CHAR_BUFFER_SIZE			; wrap write index
	CMOVB A, I
	CMOVNB A, 0
	MOV [char_buf_write_index], AL
	
	POP I
	JMP .ret

.caps_press:
	NOT byte [capslock_state]
	JMP .ret
	
.shift:
	MOV [shift_state], AL
	
.ret:
	POP A
	IRET

.shift_table:
	; converts key code to shifted character
	db 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	db 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
	db 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x22, 0x28, 0x29, 0x2A, 0x2B, 0x3C, 0x5F, 0x3E, 0x3F
	db 0x29, 0x21, 0x40, 0x23, 0x24, 0x25, 0x5E, 0x26, 0x2A, 0x28, 0x3A, 0x3A, 0x3C, 0x2B, 0x3E, 0x3F
	db 0x7E, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F
	db 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x7B, 0x7C, 0x7D, 0x22, 0x5F
	db 0x7E, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F
	db 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F

.non_shift_table:
	; converts key code to non-shifted character
	db 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	db 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
	db 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F
	db 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F
	db 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F
	db 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x5B, 0x5C, 0x5D, 0x27, 0x5F
	db 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F
	db 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F

.caps_shift_table:
	; converts key code to shifted character
	db 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	db 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
	db 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x22, 0x28, 0x29, 0x2A, 0x2B, 0x3C, 0x5F, 0x3E, 0x3F
	db 0x29, 0x21, 0x40, 0x23, 0x24, 0x25, 0x5E, 0x26, 0x2A, 0x28, 0x3A, 0x3A, 0x3C, 0x2B, 0x3E, 0x3F
	db 0x7E, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F
	db 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x22, 0x5F
	db 0x7E, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F
	db 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F

.caps_non_shift_table:
	; converts key code to non-shifted character
	db 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	db 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
	db 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F
	db 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F
	db 0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F
	db 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x27, 0x5F
	db 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F
	db 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F



; keyup
; ISR for key released
keyup:
	PUSH A
	PUSH B
	
	MOVZ A, [KEY_BUFFER]
	AND AL, 0x7F
	
	; update state table
	MOV BL, 0
	MOV [key_state_table + A], BL
	
	CMP AL, KEYCODE_SHIFT
	CMOVE [shift_state], BL
	
	POP B
	POP A
	IRET



; rtc
; Real Time Clock
rtc:
	IRET



; segfault
; ISR for segmentation fault
segfault:
	MOV A, 0x23
	MOV D, 1
	MOVW B:C, string_segfault_after - string_segfault
	MOVW J:I, string_segfault
	INT 0x20
.end:
	HLT
	JMP .end

string_segfault: db 0x1B, "[0m", 0x1B, "[HSEGMENTATION FAULT"
string_segfault_after:



; gpf
; general protection fault
gpf:
	MOV A, 0x23
	MOV D, 1
	MOVW B:C, string_gpfault_after - string_gpfault
	MOVW J:I, string_gpfault
	INT 0x20
.end:
	HLT
	JMP .end

string_gpfault: db 0x1B, "[0m", 0x1B, "[HGENERAL PROTECTION FAULT"
string_gpfault_after:



; mpf
; memory protection fault
mpf:
	MOV A, 0x23
	MOV D, 1
	MOVW B:C, string_mpfault_after - string_mpfault
	MOVW J:I, string_mpfault
	INT 0x20
.end:
	HLT
	JMP .end

string_mpfault: db 0x1B, "[0m", 0x1B, "[HMEMORY PROTECTION FAULT"
string_mpfault_after:


; syscall
; System call
syscall:
	CALLA [.table + A*4]
	IRET
	
	; table of system call handlers
.table:
	dp os.syscall_exit	; 0000
	dp os.syscall_defer	; 0001
	
	resp 14
	
	dp os.syscall_memory_allocate	; 0010
	dp os.syscall_clear_allocate	; 0011
	dp os.syscall_re_allocate		; 0012
	dp os.syscall_clear_re_allocate	; 0013
	dp os.syscall_free				; 0014
	
	resp 11
	
	dp os.syscall_open_file			; 0020
	dp os.syscall_close_file		; 0021
	dp os.syscall_read_file			; 0022
	dp os.syscall_write_file		; 0023
	dp os.syscall_seek_file			; 0024
	dp os.syscall_get_file_pos		; 0025
	dp os.syscall_change_file_attr	; 0026
